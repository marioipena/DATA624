---
title: "DATA 624 Homework 5"
author: "Mario Pena"
date: "March 13, 2022"
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(fpp3)
library(tidyverse)
```

### Exercise 8.8.1

Consider the the number of pigs slaughtered in Victoria, available in the `aus_livestock` dataset.

**a.** Use the `ETS()` function to estimate the equivalent model for simple exponential smoothing. Find the optimal values of  
α and ℓ0, and generate forecasts for the next four months.

Even though I've seen these data in previous exercises, I decided to take a look at the variables again in the next few lines of code in order to filter the data with the required variables for this exercise:

```{r}
head(aus_livestock)
```

```{r}
aus_livestock %>%
  distinct(Animal)
```

```{r}
aus_livestock %>%
  distinct(State)
```

Below, we have an example of what the graph looks like for the number of pigs in Victoria before we apply any modeling techniques:

```{r}
aus_livestock %>%
  filter(State=="Victoria" & Animal=="Pigs") %>%
  autoplot(Count)+
  labs(y="Count", title="Number of Pigs in Victoria")
```
We assign the filtered data to variable "pigs".

```{r}
#pigs data
pigs<-aus_livestock %>%
  filter(State=="Victoria" & Animal=="Pigs")
```

I borrowed some of the code from the textbook to build the model using the `ETS()` function. I have also acquired the optimal values of "alpha" and "l" below. The value of alpha is low, suggesting that more weight is given to observations from the past

```{r}
#model
fit <- pigs %>%
  model(ETS(Count ~ error("A") + trend("N") + season("N")))
fc <- fit %>%
  forecast(h = 4)

report(fit)
```

As we can observe below, the simple exponential smoothing function that we applied to model these data follows the original graph one step ahead.

```{r}
fc %>%
  autoplot(pigs) +
  geom_line(aes(y = .fitted), col="#D55E00",
            data = augment(fit)) +
  labs(y="Count", title="Number of Pigs in Victoria") +
  guides(colour = "none")
```

**b.** Compute a 95% prediction interval for the first forecast using  $\hat{y}\pm1.96s$ where s is the standard deviation of the residuals. Compare your interval with the interval produced by R.

We can observe below that the prediction interval for the first observation is [76854.79, 113518.3] generated by R.

```{r}
#prediction interval produced by R
pre_int = unpack_hilo(hilo(fc, 95) , "95%" )
pre_int
```

Now we will use the mean from the first observation and the variance from our previous report to calculate the prediction interval by hand.

```{r}
#prediction interval by hand
m <- 95186.56

s <- sqrt(87480760)

low_y <- m - 1.96 * s
up_y <- m + 1.96 * s

paste(low_y, up_y)
```

We can see that our results by hand and those of R are off by just a few decimals, thus they are practically identical.


### Exercise 8.8.5

Data set global_economy contains the annual Exports from many countries. Select one country to analyse.

**a.** Plot the Exports series and discuss the main features of the data.

I have picked Chile for this time series. We can see an upward trend with 3 big dips throughout the years. We can also observe that this trend starts to go down around the year 2008, but it is unclear whether this is another dip as we don't have data past 2017. Thus we can't see if it has gone back up.

```{r}
#Chile exports
chile_exp <- global_economy %>%
  select("Year", Exports) %>%
  filter(Country == "Chile")
autoplot(chile_exp) +
  labs(y="Exports", title="Chile Exports")
```

**b.** Use an ETS(A,N,N) model to forecast the series, and plot the forecasts.

```{r}
#model
fit2 <- (chile_exp) %>%
  model(ETS(Exports ~ error("A") + trend("N") + season("N")))
fc2 <- fit2 %>%
  forecast(h = 4)

report(fit2)
```

```{r}
fc2 %>%
  autoplot(chile_exp) +
  geom_line(aes(y = .fitted), col="#D55E00",
            data = augment(fit2))+
  labs(y="Exports", title="Chile Exports") +
  guides(colour = "none")

  
```

**c.** Compute the RMSE values for the training data.

We can observe from our `accuracy()` function below that RMSE is 2.55, which considering our range of exports from 9.55 to around 45, this is an indication that the model can relatively predict the data accurately.

```{r}
#metrics
accuracy(fit2)
```

**d.** Compare the results to those from an ETS(A,A,N) model. (Remember that the trended model is using one more parameter than the simpler model.) Discuss the merits of the two forecasting methods for this data set.

Using the `accuracy()` function below, we can see that the RMSE is practically identical to the one in the first model. In fact, most of the metrics have stayed about the same, except for ME, which has decreased in this new model as well as MPE, which seems to have inverted from positive to negative indicating a tendency to over-forecast.

```{r}
#model
fit3 <- (chile_exp) %>%
  model(ETS(Exports ~ error("A") + trend("A") + season("N")))
fc3 <- fit3 %>%
  forecast(h = 4)

accuracy(fit3)
```

**e.** Compare the forecasts from both methods. Which do you think is best?

The new model is showing a forecast with an upward trend as opposed to the first model showing a forecast of a straight line from the last observation in the data. Based on RMSE I would say that the second model is slightly better. Moreover, the additional parameter in the second model may be helping with forecasting the trend-cycle component.

```{r}
fc3 %>%
  autoplot(chile_exp) +
  geom_line(aes(y = .fitted), col="#D55E00",
            data = augment(fit3))+
  labs(y="Exports", title="Chile Exports") +
  guides(colour = "none")
```

**f.** Calculate a 95% prediction interval for the first forecast for each model, using the RMSE values and assuming normal errors. Compare your intervals with those produced using R.

The 95% prediction intervals produced by R for the first forecast for each of the two models are as follow:

```{r}
#first and second model intervals produced by R
pre_int2 = unpack_hilo(hilo(fc2, 95) , "95%" )
pre_int2

pre_int3 = unpack_hilo(hilo(fc3, 95) , "95%" )
pre_int3
```

The 95% prediction intervals done manually for the first forecast for each of the two models using RMSE values are as follow:

```{r}
#first model interval
m2 <- 28.7

rmse2 <- 2.56

low_y2 <- m2 - 1.96 * rmse2
up_y2 <- m2 + 1.96 * rmse2

paste(low_y2, up_y2)
```

```{r}
#second model interval
m3 <- 28.99

rmse3 <- 2.55

low_y3 <- m3 - 1.96 * rmse3
up_y3 <- m3 + 1.96 * rmse3

paste(low_y3, up_y3)
```

The prediction intervals produced by R and those produced by hand are very close to each other. 

### Exercise 8.8.6

Forecast the Chinese GDP from the `global_economy` data set using an ETS model. Experiment with the various options in the `ETS()` function to see how much the forecasts change with damped trend, or with a Box-Cox transformation. Try to develop an intuition of what each is doing to the forecasts.

```{r}
head(global_economy)
```

```{r}
#chinese gdp
china_gdp <- global_economy %>%
  select("Year", GDP) %>%
  filter(Country=="China")
autoplot(china_gdp) +
  labs(y="GDP", title="Chinese GDP")
```

Let's take a look at the components of these data:

```{r}
#STL decomposition
dcmp <- china_gdp %>%
  model(stl = STL(GDP))

components(dcmp) %>% autoplot()
```

We can observe an exponential growth around the year 2005, when the trend starts an upward movement. We can also oberve minimal variability toward the latest years and there does not seem to be a seasonal component in these data.

Now we will take a look at some ETS() models:

```{r}
#lambda for boxcox
lambda <- china_gdp %>%
  features(GDP, features = guerrero) %>%
  pull(lambda_guerrero)

# models
china_gdp %>%
  model(
    "Holt's Method" = ETS(GDP ~ error('A') + trend('A') + season('N')),
    "Damped Holt's Method" = ETS(GDP ~ error('A') + trend('Ad') + season('N')),
    "Box-Cox" = ETS(box_cox(GDP, lambda) ~ error('A') + trend('Ad') + season('N'))
  ) %>%
  forecast(h = 15) %>%
  autoplot(china_gdp, level = NULL) +
  labs(title = "China GDP",
       y = "GDP") +
  guides(colour = guide_legend(title = "Forecasts"))
```

We can observe above that Holt's method seems to over-forecast as it has a constant upward trend. On the other hand, the damped method seems to slowly bring the upward trend to a straight horizontal line. Interestingly, the Box-Cox combination with the damped method seems to be over-forecasting above both the previous methods. Perhaps the lambda found by the `guerrero` function might have squared our original data, hence the exponential growth.

### Exercise 8.8.7

Find an ETS model for the Gas data from `aus_production` and forecast the next few years. Why is multiplicative seasonality necessary here? Experiment with making the trend damped. Does it improve the forecasts?

```{r}
head(aus_production)
aus_production %>%
  autoplot(Gas) +
  labs(title = "Australian Gas Production")
```

Below we can observe that we have an increasing trend, seasonality as well as variation.

```{r}
#STL decomposition
dcmp2 <- aus_production %>%
  model(stl = STL(Gas))

components(dcmp2) %>% autoplot()
```

```{r}
# models
fit4 <- aus_production %>%
  model(
    "Additive" = ETS(Gas ~ error('A') + trend('A') + season('A')),
    "Multiplicative" = ETS(Gas ~ error('M') + trend('A') + season('M')),
    "Damped Holt's Method" = ETS(Gas ~ error('A') + trend('Ad') + season('M'))
  )

fc4 <- fit4 %>%
  forecast(h = 15)

fc4 %>% autoplot(aus_production, level = NULL) +
  labs(title = "Australian Gas Production") +
  guides(colour = guide_legend(title = "Forecasts"))
```

```{r}
accuracy(fit4)
```

We can see above from the graph and accuracy metrics that the Multiplicative method is slightly better than the Additive method. The Multiplicative method is preferred when the seasonal variations are changing proportional to the level of the series. Additionally, the damped method does seem to slightly improve the forecasts.

### Exercise 8.8.8

Recall your retail time series data (from Exercise 8 in Section 2.10).

```{r}
set.seed(123)
myseries <- aus_retail %>%
  filter(`Series ID` == sample(aus_retail$`Series ID`,1))
```

**a.** Why is multiplicative seasonality necessary for this series?

As observed previously with the data from gas production, we can observe that these data have an increasing trend, seasonality as well as variation. As discussed earlier, the Multiplicative method is preferred when the seasonal variations are changing proportional to the level of the series.

```{r}
#STL decomposition
dcmp3 <- myseries %>%
  model(stl = STL(Turnover))

components(dcmp3) %>% autoplot()
```

we can also compare below the Multipliatie and Additive methods and conclude that the Multiplicative method is better.

```{r}
fit5 <- myseries %>%
  model(
    "Additive" = ETS(Turnover ~ error('A') + trend('A') + season('A')),
    "Multiplicative" = ETS(Turnover ~ error('M') + trend('A') + season('M'))
  )

fc5 <- fit5 %>%
  forecast(h = 10)

fc5 %>% autoplot(myseries, level = NULL) +
  labs(title = "Household Goods Turnover") +
  guides(colour = guide_legend(title = "Forecasts"))
```

```{r}
accuracy(fit5)
```

**b.** Apply Holt-Winters’ multiplicative method to the data. Experiment with making the trend damped.

```{r}
fit6 <- myseries %>%
  model(
    "Holt-Winter" = ETS(Turnover ~ error('M') + trend('Ad') + season('M')),
    "Damped Holt's Method" = ETS(Turnover ~ error('A') + trend('Ad') + season('M'))
  )

fc6 <- fit6 %>%
  forecast(h = 15)

fc6 %>% autoplot(myseries, level = NULL) +
  labs(title = "Household Goods Turnover") +
  guides(colour = guide_legend(title = "Forecasts"))
```

**c.** Compare the RMSE of the one-step forecasts from the two methods. Which do you prefer?

In this case the damped methods seems to be slightly better than the Holt-Winter method, and they both clearly outperform the Multiplicative method in our previous example.

```{r}
accuracy(fit6)
```

**d.** Check that the residuals from the best method look like white noise.

It seems that the residuals on the time plot show a slight increase in variability from the year 2000 and on. We can also observe that there is some correlation on the ACF of the residuals but the histogram seems to be close to normal.

```{r}
best_fit <- myseries %>%
  model(
    "Damped Holt's Method" = ETS(Turnover ~ error('A') + trend('Ad') + season('M'))
  )

best_fc <- best_fit %>%
  forecast(h = 15)

best_fit %>% gg_tsresiduals()
```

**e.** Now find the test set RMSE, while training the model to the end of 2010. Can you beat the seasonal naïve approach from Exercise 7 in Section 5.11?

```{r}
myseries_train <- myseries %>%
  filter(year(Month) < 2011)

fit_train <- myseries_train %>%
  model(
    "SNAIVE" = SNAIVE(Turnover),
    "Damped Holt's Method" = ETS(Turnover ~ error('A') + trend('Ad') + season('M'))
  )

fc_train <- fit_train %>%
  forecast(h = 15)

fc_train %>% autoplot(myseries_train, level = NULL) +
  labs(title = "Household Goods Turnover") +
  guides(colour = guide_legend(title = "Forecasts"))
```

```{r}
fc_train %>% accuracy(myseries)
```

We can conclude from the above graph and accuracy metrics that the damped method is superior to the seasonal naive approach.


### Exercise 8.8.9

For the same retail data, try an STL decomposition applied to the Box-Cox transformed series, followed by ETS on the seasonally adjusted data. How does that compare with your best previous forecasts on the test set?

```{r}
#lambda for boxcox
lambda2 <- myseries_train %>%
  features(Turnover, features = guerrero) %>%
  pull(lambda_guerrero)
```

```{r}
#boxcox transformation
myseries_train_bx <- myseries_train
myseries_train_bx$Turnover <- box_cox(myseries_train$Turnover,lambda2)
```

As we can observe below, the Box-Cox transformation made the seasonality a lot more constant as well as the variability in the remainder.

```{r}
#STL decomposition
dcmp4 <- myseries_train_bx %>%
  model(stl = STL(Turnover))

components(dcmp4) %>% autoplot()
```

```{r}
fit_train2 <- myseries_train_bx %>%
  model(
    "Damped Holt's Method" = ETS(Turnover ~ error('A') + trend('Ad') + season('M'))
  )

fc_train2 <- fit_train2 %>%
  forecast(h = 15)

fc_train2 %>% autoplot(myseries_train_bx, level = NULL) +
  labs(title = "Household Goods Turnover") +
  guides(colour = guide_legend(title = "Forecasts"))
```

```{r}
accuracy(fit_train)
accuracy(fit_train2)
```

According to our accuracy metrics above, it appears that the model improved with the Box-Cox transformation and it now outperforms the best version of our model in the previous exercise. However, I believe we would have to scale the data back to their original form to make a more accurate comparison.

